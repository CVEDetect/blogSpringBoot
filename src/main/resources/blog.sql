/*
SQLyog Ultimate v12.09 (64 bit)
MySQL - 5.7.28 : Database - myblog
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`myblog` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `myblog`;

/*Table structure for table `t_blog` */

DROP TABLE IF EXISTS `t_blog`;

CREATE TABLE `t_blog` (
  `bl_id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(32) NOT NULL,
  `content` text,
  `outline` varchar(256) NOT NULL,
  `flag` varchar(32) DEFAULT NULL,
  `recommend` tinyint(1) DEFAULT '1',
  `commentabled` tinyint(1) DEFAULT '1',
  `published` tinyint(1) DEFAULT '1',
  `creatdate` datetime DEFAULT NULL,
  `finaldate` datetime DEFAULT NULL,
  `views` int(11) DEFAULT '0',
  `ty_id` int(11) NOT NULL,
  PRIMARY KEY (`bl_id`),
  KEY `ty_id` (`ty_id`),
  CONSTRAINT `t_blog_ibfk_1` FOREIGN KEY (`ty_id`) REFERENCES `t_type` (`ty_id`)
) ENGINE=InnoDB AUTO_INCREMENT=44 DEFAULT CHARSET=utf8;

/*Data for the table `t_blog` */

insert  into `t_blog`(`bl_id`,`title`,`content`,`outline`,`flag`,`recommend`,`commentabled`,`published`,`creatdate`,`finaldate`,`views`,`ty_id`) values (1,'CAS','<h5>CAS全称Compare-And-Swap,他是一条cpu并发原语.</h5>\n<h5>它的功能是判断内存某个位置是否是预期值,是的话更改为更新值,是一条原子操作.</h5>\n<h5>CAS并发原语在java语言中是sun.misc.Unsafe 类中的各个方法. 调用Unsafe类中的CAS方法,JVM会帮我们实现出CAS汇编指令,这是一种完全依赖硬件的功能,通过它实现了原子操作.</h5>\n<h5>由于CAS是一种系统原语,原语属于操作系统范畴,由若干条指令组成,用于完成某一功能的过程.</h5>\n<h5>并且原语的执行过程必须是连续的.在执行过程中无法被打断,所以不会造成数据不一致问题.</h5>\n<h4 id=\"UnSafe-类\">UnSafe 类</h4>\n<pre class=\"language-java\"><code>public class AtomicInteger extends Number implements java.io.Serializable {\n    private static final long serialVersionUID = 6214790243416807050L;\n\n    // setup to use Unsafe.compareAndSwapInt for updates\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\n    private static final long valueOffset;\n\n    static {\n        try {\n            // 获取下面 value 的地址偏移量\n            valueOffset = unsafe.objectFieldOffset\n                (AtomicInteger.class.getDeclaredField(\"value\"));\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n\n    private volatile int value;\n	// ...\n}</code></pre>\n<ul>\n<li>Unsafe 是 CAS 的核心类，由于 Java 方法无法直接访问底层系统，而需要通过本地（native）方法来访问， Unsafe 类相当一个后门，基于该类可以直接操作特定内存的数据。Unsafe 类存在于 sun.misc 包中，其内部方法操作可以像 C 指针一样直接操作内存，因为 Java 中 CAS 操作执行依赖于 Unsafe 类。</li>\n<li>变量 vauleOffset，表示该变量值在内存中的偏移量，因为 Unsafe 就是根据内存偏移量来获取数据的。</li>\n<li>变量 value 用 volatile 修饰，保证了多线程之间的内存可见性。</li>\n</ul>\n<p><strong>getAndAddInt 方法</strong></p>\n<pre class=\"language-java\"><code>// unsafe.getAndAddInt\npublic final int getAndAddInt(Object obj, long valueOffset, long expected, int val) {\n    int temp;\n    do {\n        temp = this.getIntVolatile(obj, valueOffset);  // 获取快照值\n    } while (!this.compareAndSwap(obj, valueOffset, temp, temp + val));  // 如果此时 temp 没有被修改，就能退出循环，否则重新获取\n    return temp;\n}</code></pre>\n<h3 id=\"CAS-的缺点？\">CAS 的缺点</h3>\n<ul>\n<li>循环时间长开销很大\n<ul>\n<li>如果 CAS 失败，会一直尝试，如果 CAS 长时间一直不成功，可能会给 CPU 带来很大的开销（比如线程数很多，每次比较都是失败，就会一直循环），所以希望是线程数比较小的场景。</li>\n</ul>\n</li>\n<li>只能保证一个共享变量的原子操作\n<ul>\n<li>对于多个共享变量操作时，循环 CAS 就无法保证操作的原子性。</li>\n</ul>\n</li>\n<li>引出 ABA 问题</li>\n</ul>\n<h5 style=\"padding-left: 40px;\">ABA 问题是怎么产生的？当有一个值从 A 改为 B 又改为 A，这就是 ABA 问题。<br /><br />解决方案：时间戳原子引用</h5>','CAS全称Compare-And-Swap,他是一条cpu并发原语.',NULL,0,1,1,'2019-11-26 14:00:00','2019-11-26 13:45:10',0,1),(4,'反射中Class.forName和classloader区别','<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;在java中Class.forName()和ClassLoader都可以对类进行加载。ClassLoader就是遵循<strong>双亲委派模型</strong>最终调用启动类加载器的类加载器，实现的功能是&ldquo;通过一个类的全限定名来获取描述此类的二进制字节流&rdquo;，获取到二进制流后放到JVM中。Class.forName()方法实际上也是调用的CLassLoader来实现的。</p>\n<p>&nbsp; &nbsp;&nbsp;&nbsp; Class.forName(String className)；这个方法的源码是</p>\n<pre class=\"language-java\"><code> @CallerSensitive\n    public static Class&lt;?&gt; forName(String className)\n                throws ClassNotFoundException {\n        Class&lt;?&gt; caller = Reflection.getCallerClass();\n        return forName0(className, true, ClassLoader.getClassLoader(caller), caller);\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;最后调用的方法是forName0这个方法，在这个forName0方法中的第二个参数被默认设置为了true，这个参数代表是否对加载的类进行初始化，设置为true时会类进行初始化，代表会执行类中的静态代码块，以及对静态变量的赋值等操作。</p>\n<p>也可以调用Class.forName(String name, boolean initialize,ClassLoader loader)方法来手动选择在加载类的时候是否要对类进行初始化。Class.forName(String name, boolean initialize,ClassLoader loader)的源码如下：</p>\n<pre class=\"language-java\"><code> @CallerSensitive\n    public static Class&lt;?&gt; forName(String name, boolean initialize,\n                                   ClassLoader loader)\n        throws ClassNotFoundException\n    {\n        Class&lt;?&gt; caller = null;\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            // Reflective call to get caller class is only needed if a security manager\n            // is present.  Avoid the overhead of making this call otherwise.\n            caller = Reflection.getCallerClass();\n            if (sun.misc.VM.isSystemDomainLoader(loader)) {\n                ClassLoader ccl = ClassLoader.getClassLoader(caller);\n                if (!sun.misc.VM.isSystemDomainLoader(ccl)) {\n                    sm.checkPermission(\n                        SecurityConstants.GET_CLASSLOADER_PERMISSION);\n                }\n            }\n        }\n        return forName0(name, initialize, loader, caller);\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;源码中的注释描述中，其中对参数initialize的描述是：if {@code true} the class will be initialized.意思就是说：如果参数为true，则加载的类将会被初始化。</p>\n<hr />\n<h1 class=\"title-article\">&nbsp;&nbsp;&nbsp;类加载过程</h1>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; <strong>1：加载</strong>&nbsp;&nbsp;&nbsp;Jvm把class文件字节码加载到内存中，并将这些静态数据装换成运行时数据区中方法区的类型数据，在运行时数据区堆中生成一个代表这个类</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;2：链接</strong>：执行下面的校验、准备和解析步骤，其中解析步骤是可选的</p>\n<p>　　　　a：校验：检查加载的class文件的正确性和安全性</p>\n<p>　　　　b：准备：为类变量分配存储空间并设置类变量初始值，类变量随类型信息存放在方法区中,生命周期很长，使用不当和容易造成内存泄漏。</p>\n<p><em>　　　　*</em><em><strong>释</strong>：类变量就是</em><em>static</em><em>变量；初始值指的是类变量类型的默认值而不是实际要赋的值</em></p>\n<p>　　　　c：解析：jvm将常量池内的符号引用转换为直接引用</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;3：初始化</strong>：执行类变量赋值和静态代码块</p>\n<hr />\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;Class.forName得到的class是已经初始化完成的</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;Classloder.loaderClass得到的class是还没有链接的</p>\n<hr />\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;有些情况是只需要知道这个类的存在而不需要初始化的情况使用Classloder.loaderClass，而有些时候又必须执行初始化就选择Class.forName</p>\n<p>　　例如：数据库驱动加载就是使用Class.froName(&ldquo;com.mysql.jdbc.Driver&rdquo;),</p>\n<hr />\n<p><a href=\"https://www.cnblogs.com/jimoer/p/9185662.html\" target=\"_blank\" rel=\"noopener\">原文：https://www.cnblogs.com/jimoer/p/9185662.html</a></p>','为什么要把ClassLoader.loadClass(String name)和Class.forName(String name)进行比较呢，因为他们都能在运行时对任意一个类，都能够知道该类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性。',NULL,1,1,1,'2019-11-26 14:00:00','2019-11-27 12:18:21',0,6),(5,'多线程中的虚假唤醒','<div>\n<h1>什么是虚假唤醒？</h1>\n</div>\n<div>一般而言线程调用wait()方法后，需要其他线程调用notify,notifyAll方法后，线程才会从wait方法中返回， 而虚假唤醒(spurious wakeup)是指线程通过其他方式，从wait方法中返回。</div>\n<div>&nbsp;</div>\n<div>假设有两个消费者线程，两个生产者线程。</div>\n<div>先上错误代码，是用if的情况：</div>\n<div>\n<pre class=\"language-java\"><code>public class AirCondition {\n    private int num=0;\n\n    private synchronized void production() throws InterruptedException {\n        //1.判断\n        if(num&gt;=1){\n            this.wait();\n        }\n        //2.执行\n        this.num++;\n        System.out.println(Thread.currentThread().getName()+\"生产1个此时资源量：\"+num);\n        //3.通知\n        notifyAll();\n\n    }\n    private synchronized void consume() throws InterruptedException {\n        if(num&lt;=0){\n            this.wait();\n        }\n        this.num--;\n        System.out.println(Thread.currentThread().getName()+\"消费1个此时资源量：\"+num);\n        notifyAll();\n    }\n    \n    public static void main(String[] args) {\n        AirCondition airCondition=new AirCondition();\n        new Thread(()-&gt;{\n            for (int i=0;i&lt;10;i++){\n                try {\n                    airCondition.consume();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n\n        },\"消费者1\").start();\n\n        new Thread(()-&gt;{\n            for (int i=0;i&lt;10;i++){\n                try {\n                    airCondition.consume();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n\n        },\"消费者2\").start();\n\n        new Thread(()-&gt;{\n            for (int i=0;i&lt;10;i++){\n                try {\n                    airCondition.production();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n\n        },\"生产者1\").start();\n\n        new Thread(()-&gt;{\n            for (int i=0;i&lt;10;i++){\n                try {\n                    airCondition.production();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n\n        },\"生产者2\").start();\n    }\n\n}</code></pre>\n<pre class=\"language-java\"><code>生产者1生产1个此时资源量：1\n消费者2消费1个此时资源量：0\n消费者1消费1个此时资源量：-1\n生产者2生产1个此时资源量：0\n生产者2生产1个此时资源量：1\n消费者1消费1个此时资源量：0\n消费者2消费1个此时资源量：-1\n生产者1生产1个此时资源量：0\n生产者1生产1个此时资源量：1\n消费者2消费1个此时资源量：0\n消费者1消费1个此时资源量：-1\n生产者2生产1个此时资源量：0\n生产者2生产1个此时资源量：1\n消费者1消费1个此时资源量：0\n消费者2消费1个此时资源量：-1\n生产者1生产1个此时资源量：0\n生产者1生产1个此时资源量：1\n消费者2消费1个此时资源量：0\n消费者1消费1个此时资源量：-1\n生产者2生产1个此时资源量：0\n生产者2生产1个此时资源量：1\n消费者1消费1个此时资源量：0\n消费者2消费1个此时资源量：-1\n生产者1生产1个此时资源量：0\n生产者1生产1个此时资源量：1\n消费者2消费1个此时资源量：0\n消费者1消费1个此时资源量：-1\n生产者2生产1个此时资源量：0\n生产者2生产1个此时资源量：1\n消费者1消费1个此时资源量：0\n消费者2消费1个此时资源量：-1\n生产者1生产1个此时资源量：0\n生产者1生产1个此时资源量：1\n消费者2消费1个此时资源量：0\n消费者1消费1个此时资源量：-1\n生产者2生产1个此时资源量：0\n生产者2生产1个此时资源量：1\n消费者1消费1个此时资源量：0\n消费者2消费1个此时资源量：-1\n生产者1生产1个此时资源量：0</code></pre>\n<p>发现执行时资源量出现了-1的情况原因：</p>\n</div>\n<ol>\n<li>消费者1号线程抢到锁，进入同步代码块，发现没有资源，消费者1进入wait等待状态，外面三个线程竞争锁。</li>\n<li>消费者2号线程抢到锁，进入同步代码块，发现没有资源，消费者2进入wait等待状态，外面两个线程竞争锁。（此时消费者1,2都处于等待状态）</li>\n<li>生产者1号线程抢到锁，进入同步代码块，发现没有资源，执行生产资源，然后notifyAll。（此时消费者1,2都被唤醒）</li>\n<li>消费者1从wait往后执行，不在进行if判断 消费了1个资源，资源剩余成为0。</li>\n<li>消费者2从wait往后执行，不在进行if判断 消费了1个资源，资源剩余成为-1。（bug产生）</li>\n</ol>\n<div>解决的办法是条件判断通过</div>\n<div><span style=\"color: #ff0000;\">while(条件){</span></div>\n<div><span style=\"color: #ff0000;\">&nbsp; this.wait();</span></div>\n<div><span style=\"color: #ff0000;\">}</span></div>\n<div>来解决</div>\n<div>使用while后的结果：</div>\n<div>\n<pre class=\"language-java\"><code>生产者1生产1个此时资源量：1\n消费者2消费1个此时资源量：0\n生产者1生产1个此时资源量：1\n消费者1消费1个此时资源量：0\n生产者1生产1个此时资源量：1\n消费者2消费1个此时资源量：0\n生产者1生产1个此时资源量：1\n消费者1消费1个此时资源量：0\n生产者1生产1个此时资源量：1\n消费者2消费1个此时资源量：0\n生产者1生产1个此时资源量：1\n消费者1消费1个此时资源量：0\n生产者1生产1个此时资源量：1\n消费者2消费1个此时资源量：0\n生产者1生产1个此时资源量：1\n消费者1消费1个此时资源量：0\n生产者1生产1个此时资源量：1\n消费者2消费1个此时资源量：0\n生产者1生产1个此时资源量：1\n消费者1消费1个此时资源量：0\n生产者2生产1个此时资源量：1\n消费者2消费1个此时资源量：0\n生产者2生产1个此时资源量：1\n消费者1消费1个此时资源量：0\n生产者2生产1个此时资源量：1\n消费者2消费1个此时资源量：0\n生产者2生产1个此时资源量：1\n消费者1消费1个此时资源量：0\n生产者2生产1个此时资源量：1\n消费者2消费1个此时资源量：0\n生产者2生产1个此时资源量：1\n消费者1消费1个此时资源量：0\n生产者2生产1个此时资源量：1\n消费者2消费1个此时资源量：0\n生产者2生产1个此时资源量：1\n消费者1消费1个此时资源量：0\n生产者2生产1个此时资源量：1\n消费者2消费1个此时资源量：0\n生产者2生产1个此时资源量：1\n消费者1消费1个此时资源量：0</code></pre>\n</div>\n<div>此时能够正常运行了。</div>\n<div>&nbsp;</div>\n<div>贴一下正确的代码：\n<pre class=\"language-java\"><code>public class AirCondition {\n    private int num=0;\n\n    private synchronized void production() throws InterruptedException {\n        //1.判断\n        while(num&gt;=1){\n            this.wait();\n        }\n        //2.执行\n        this.num++;\n        System.out.println(Thread.currentThread().getName()+\"生产1个此时资源量：\"+num);\n        //3.通知\n        notifyAll();\n\n    }\n    private synchronized void consume() throws InterruptedException {\n        while(num&lt;=0){\n            this.wait();\n        }\n        this.num--;\n        System.out.println(Thread.currentThread().getName()+\"消费1个此时资源量：\"+num);\n        notifyAll();\n    }\n\n    public static void main(String[] args) {\n        AirCondition airCondition=new AirCondition();\n        new Thread(()-&gt;{\n            for (int i=0;i&lt;10;i++){\n                try {\n                    airCondition.consume();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n\n        },\"消费者1\").start();\n\n        new Thread(()-&gt;{\n            for (int i=0;i&lt;10;i++){\n                try {\n                    airCondition.consume();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n\n        },\"消费者2\").start();\n\n        new Thread(()-&gt;{\n            for (int i=0;i&lt;10;i++){\n                try {\n                    airCondition.production();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n\n        },\"生产者1\").start();\n\n        new Thread(()-&gt;{\n            for (int i=0;i&lt;10;i++){\n                try {\n                    airCondition.production();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n\n        },\"生产者2\").start();\n    }\n\n}\n​</code></pre>\n</div>\n<h1>使用while()判断的原因</h1>\n<div><span style=\"color: #ff0000;\">while即使在条件成立的时候也还会再执行一次，而if判断条件成立了，就直接向下执行了</span></div>\n<div>&nbsp;</div>\n<div>\n<div>&nbsp;</div>\n<div>wait方法可以分为三个操作：</div>\n<div>（1）释放锁并阻塞</div>\n<div>（2）等待条件cond发生</div>\n<div>（3）获取通知后，竞争获取锁</div>\n</div>\n<div>在多核处理器下，pthread_cond_signal可能会激活多于一个线程（阻塞在条件变量上的线程）。结果就是，当一个线程调用pthread_cond_signal()后，多个调用pthread_cond_wait()或pthread_cond_timedwait()的线程返回。这种效应就称为&ldquo;虚假唤醒&rdquo;。</div>','多线程使用while()判断wait的原因',NULL,1,1,1,'2019-11-26 14:00:00','2019-11-29 15:38:31',0,1),(6,'JMM（Java 内存模型）','<h4 id=\"基本概念\">基本概念</h4>\n<ul>\n<li>JMM 本身是一种抽象的概念并不是真实存在，它描述的是一组规定或则规范，通过这组规范定义了程序中的访问方式。</li>\n<li>JMM 同步规定\n<ul>\n<li>线程解锁前，必须把共享变量的值刷新回主内存</li>\n<li>线程加锁前，必须读取主内存的最新值到自己的工作内存</li>\n<li>加锁解锁是同一把锁</li>\n</ul>\n</li>\n<li>由于 JVM 运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存，工作内存是每个线程的私有数据区域，而 Java 内存模型中规定所有变量的储存在主内存，主内存是共享内存区域，所有的线程都可以访问，但线程对变量的操作（读取赋值等）必须都工作内存进行看。</li>\n<li>首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。</li>\n</ul>\n<p>内存模型图</p>\n<p><img src=\"http://blog.cuzz.site/2019/04/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20190416211412.png\" alt=\"\" /></p>','JMM 本身是一种抽象的概念并不是真实存在，它描述的是一组规定或则规范，通过这组规范定义了程序中的访问方式。',NULL,0,1,1,'2019-11-26 14:00:00','2019-11-26 13:21:48',0,1),(7,'对volatile的理解','<div><span style=\"color: #ff0000;\">volatile:1 保证可见性 2 禁止指令重排 3 不保证原子性</span></div>\n<div>&nbsp;</div>\n<h5>以多核CPU为例（两核），我们知道CPU的速度比内存要快得多，为了弥补这个性能差异，CPU内核都会有自己的高速缓存区，当内核运行的线程执行一段代码时，首先将这段代码的指令集进行缓存行填充到高速缓存，如果非volatil变量当CPU执行修改了此变量之后，会将修改后的值回写到高速缓存，然后再刷新到内存中。如果在刷新会内存之前，由于是共享变量，那么CORE2中的线程执行的代码也用到了这个变量，这是变量的值依然是旧的。volatile关键字就会解决这个问题的，如何解决呢，首先被volatile关键字修饰的共享变量在转换成汇编语言时，会加上一个以lock为前缀的指令，当CPU发现这个指令时，立即做两件事：</h5>\n<h5>1.将当前内核高速缓存行的数据立刻回写到内存；</h5>\n<h5>2.使在其他内核里缓存了该内存地址的数据无效。</h5>\n<h5>第一步很好理解，第二步如何做到呢？</h5>\n<h5>MESI协议：在早期的CPU中，是通过在总线加LOCK#锁的方式实现的，但这种方式开销太大，所以Intel开发了缓存一致性协议，也就是MESI协议，该解决缓存一致性的思路是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，那么他会发出信号通知其他CPU将该变量的缓存行设置为无效状态。当其他CPU使用这个变量时，首先会去嗅探是否有对该变量更改的信号，当发现这个变量的缓存行已经无效时，会从新从内存中读取这个变量。</h5>\n<h5>并发编程的三大概念</h5>\n<h5><strong>可见性</strong></h5>\n<h5>可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</h5>\n<h5>可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是线程修改的结果。</h5>\n<h5>另一个线程马上就能看到。比如：用volattitle修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让他修饰内容具有可见性，但不能保证他具有原子性。比如 volatile int a = 0;之后有一个操作 a++;这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。</h5>\n<h5>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</h5>\n<h5>在 Java 中通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</h5>\n<h5><strong>原子性</strong></h5>\n<h5>原子是世界上的最小单位，具有不可分割性。原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</h5>\n<h5>比如 a=0;(a非long和double类型) 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++; 这个操作实际是a = a + 1;是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术(sychronized)来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。</h5>\n<h5>Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</h5>\n<h5><strong>有序性</strong></h5>\n<h5>有序性就是程序执行的顺序按照代码的先后顺序执行。</h5>\n<h5>什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</h5>\n<h5>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</h5>\n<h5>在Java里面，可以通过volatile关键字来保证一定的&ldquo;有序性&rdquo;。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</h5>\n<h5>另外，Java内存模型具备一些先天的&ldquo;有序性&rdquo;，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序</h5>\n<div><hr /></div>\n<div>\n<h4 id=\"禁止指令排序\">禁止指令排序</h4>\n<p>volatile 实现禁止指令重排序的优化，从而避免了多线程环境下程序出现乱序的现象</p>\n<p>先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个 CPU 指令，他的作用有两个：</p>\n<ul>\n<li>保证特定操作的执行顺序</li>\n<li>保证某些变量的内存可见性（利用该特性实现 volatile 的内存可见性）</li>\n</ul>\n<p>由于编译器个处理器都能执行指令重排序优化，如果在指令间插入一条 Memory Barrier 则会告诉编译器和 CPU，不管什么指令都不能个这条 Memory Barrier 指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后执行重排序优化。内存屏障另一个作用是强制刷出各种 CPU 缓存数据，因此任何 CPU 上的线程都能读取到这些数据的最新版本。</p>\n<p>下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图：</p>\n<p><img src=\"http://blog.cuzz.site/2019/04/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/0e75180bf35c40e2921493d0bf6bd684_th.png\" alt=\"\" /></p>\n<p>下面是在保守策略下，volatile读插入内存屏障后生成的指令序列示意图：</p>\n<p><img src=\"http://blog.cuzz.site/2019/04/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/21ebc7e8190c4966948c4ef4424088be_th.png\" alt=\"\" /></p>\n<h4 id=\"线程安全性保证\">线程安全性保证</h4>\n<ul>\n<li>工作内存与主内存同步延迟现象导致可见性问题\n<ul>\n<li>可以使用 synchronzied 或 volatile 关键字解决，它们可以使用一个线程修改后的变量立即对其他线程可见</li>\n</ul>\n</li>\n<li>对于指令重排导致可见性问题和有序性问题\n<ul>\n<li>可以利用 volatile 关键字解决，因为 volatile 的另一个作用就是禁止指令重排序优化</li>\n</ul>\n</li>\n</ul>\n</div>\n<div><hr />\n<h1 class=\"_1RuRku\">双重校验单例模式的经典实现，这里使用volatile防止指令重排</h1>\n<pre class=\"line-numbers  language-java\"><code>class Singleton{\n    private volatile static Singleton singleton;   \n    public static Singleton getInstance(){       \n\n        if(singleton == null){                      // 语句1\n            synchronized(Singleton.class){          // 语句2\n                if(singleton == null){              // 语句3\n                    singleton = new Singleton();    // 语句4\n                }\n            }\n        } \n        \n        return singleton;           \n    }\n}</code></pre>\n<pre class=\"line-numbers  language-tsx\"><code>new 一个对象实际是4个步骤：\na. 看class对象是否加载，如果没有就先加载class对象，\nb. 分配内存空间，初始化实例。\nc. 调用构造函数。\nd. 返回地址给引用。</code></pre>\n<div>\n<div>\n<h6>不加volatile会出现什么问题</h6>\n<ul>\n<li>两个线程A,B B执行到了语句4，A执行到了语句1</li>\n<li>B因为指令重排，c，d被颠倒了，恰好d执行完了,c还没执行的时候B被挂起了。</li>\n<li>此时A运行到了语句1， 发现<code>singleton</code>不等于null,于是将还没构造完成的singleton对象返回给了上层调用。</li>\n</ul>\n</div>\n</div>\n</div>','1 保证可见性 2 禁止指令重排 3 不保证原子性',NULL,0,1,1,'2019-11-26 14:00:00','2019-11-26 13:33:56',0,1),(8,'JAVA垃圾回收-可达性分析算法','<p>在java中是通过引用来和对象进行关联的，也就是说如果要操作对象，必须通过引用来进行。那么很显然一个简单的办法就是通过引用计数来判断一个对象是否可以被回收。不失一般性，如果一个对象没有任何引用与之关联，则说明该对象基本不太可能在其他地方被使用到，那么这个对象就成为可被回收的对象了。这种方式成为引用计数法。</p>\n<p>这种方式的特点是实现简单，而且效率较高，但是它无法解决循环引用的问题，因此在Java中并没有采用这种方式（Python采用的是引用计数法）。看下面这段代码：</p>\n<pre class=\"language-java\"><code>public class Main {\n    public static void main(String[] args) {\n        MyObject object1 = new MyObject();\n        MyObject object2 = new MyObject();\n \n        object1.object = object2;\n        object2.object = object1;\n \n        object1 = null;\n        object2 = null;\n    }\n}\n \nclass MyObject{\n    public Object object = null;\n}</code></pre>\n<p><span style=\"color: #ff0000;\">最后面两句将object1和object2赋值为null，也就是说object1和object2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数都不为0，那么垃圾收集器就永远不会回收它们。</span></p>\n<p>&nbsp;</p>\n<p>为了解决这个问题，在Java中采取了 可达性分析法。该方法的基本思想是通过一系列的&ldquo;GC Roots&rdquo;对象作为起点进行搜索，如果在&ldquo;GC Roots&rdquo;和一个对象之间没有可达路径，则称该对象是不可达的，不过要注意的是被判定为不可达的对象不一定就会成为可回收对象。被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。最后面两句将object1和object2赋值为null，也就是说object1和object2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数都不为0，那么垃圾收集器就永远不会回收它们。</p>\n<p>Java并不采用引用计数法来判断对象是否已&ldquo;死&rdquo;，而采用&ldquo;可达性分析&rdquo;来判断对象是否存活（同样采用此法的还有C#、Lisp-最早的一门采用动态内存分配的语言）。&nbsp;<br />此算法的核心思想：通过一系列称为&ldquo;GC Roots&rdquo;的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为&ldquo;引用链&rdquo;，当一个对象到 GC Roots 没有任何的引用链相连时(从 GC Roots 到这个对象不可达)时，证明此对象不可用。以下图为例：</p>\n<p><img src=\"https://img-blog.csdn.net/20180626084654607?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1YnVqaWFuX2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\" width=\"714\" height=\"534\" /></p>\n<p>对象Object5 &mdash;Object7之间虽然彼此还有联系，但是它们到 GC Roots 是不可达的，因此它们会被判定为可回收对象。</p>\n<p>在Java语言中，可作为GC Roots的对象包含以下几种：</p>\n<ol>\n<li>虚拟机栈(栈帧中的本地变量表)中引用的对象。(可以理解为:引用栈帧中的本地变量表的所有对象)</li>\n<li>方法区中静态属性引用的对象(可以理解为:引用方法区该静态属性的所有对象)</li>\n<li>方法区中常量引用的对象(可以理解为:引用方法区中常量的所有对象)</li>\n<li>本地方法栈中(Native方法)引用的对象(可以理解为:<span style=\"color: #ff0000;\">引用Native方法的所有对象</span>)</li>\n</ol>\n<p>可以理解为:</p>\n<p>(1)<span style=\"color: #ff0000;\">首先第一种是虚拟机栈中的引用的对象，我们在程序中正常创建一个对象</span>，对象会在堆上开辟一块空间，同时会将这块空间的地址作为引用保存到虚拟机栈中，如果对象生命周期结束了，那么引用就会从虚拟机栈中出栈，因此如果在虚拟机栈中有引用，就说明这个对象还是有用的，这种情况是最常见的。</p>\n<p>(2)<span style=\"color: #ff0000;\">第二种是我们在类中定义了全局的静态的对象，也就是使用了static关键字</span>，由于虚拟机栈是线程私有的，所以这种对象的引用会保存在共有的方法区中，显然将方法区中的静态引用作为GC Roots是必须的。</p>\n<p>(3)<span style=\"color: #ff0000;\">第三种便是常量引用，就是使用了static final关键字</span>，由于这种引用初始化之后不会修改，所以方法区常量池里的引用的对象也应该作为GC Roots。最后一种是在使用JNI技术时，有时候单纯的Java代码并不能满足我们的需求，我们可能需要在Java中调用C或C++的代码，因此会使用native方法，JVM内存中专门有一块本地方法栈，用来保存这些对象的引用，所以本地方法栈中引用的对象也会被作为GC Roots。</p>\n<p><strong>JVM之判断对象是否存活（引用计数算法、可达性分析算法，最终判定）</strong></p>\n<p><strong>finalize()方法最终判定对象是否存活:</strong></p>\n<p>&nbsp;&nbsp;&nbsp; 即使在可达性分析算法中不可达的对象，也并非是&ldquo;非死不可&rdquo;的，这时候它们暂时处于&ldquo;缓刑&rdquo;阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。<br />&nbsp;&nbsp;&nbsp; 标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。<br />&nbsp;&nbsp;1).第一次标记并进行一次筛选。<br />&nbsp;&nbsp;&nbsp; 筛选的条件是此对象是否有必要执行finalize()方法。<br />&nbsp;&nbsp;&nbsp; 当对象没有覆盖finalize方法，或者finzlize方法已经被虚拟机调用过，虚拟机将这两种情况都视为&ldquo;没有必要执行&rdquo;，对象被回收。<br /><br />&nbsp;&nbsp;2).第二次标记<br />&nbsp;&nbsp;&nbsp; 如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为：F-Queue的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的&ldquo;执行&rdquo;是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。<br />&nbsp;&nbsp;&nbsp; Finalize（）方法是对象脱逃死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize（）中成功拯救自己----只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出&ldquo;即将回收&rdquo;的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。<br />流程图如下：</p>\n<p><img src=\"https://img-blog.csdn.net/20160514190019348\" alt=\"\" width=\"872\" height=\"341\" /></p>\n<p>在JDK1.2以前，Java中引用的定义很传统: 如果引用类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。这种定义有些狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态。&nbsp;<br />我们希望能描述这一类对象: 当内存空间还足够时，则能保存在内存中；如果内存空间在进行垃圾回收后还是非常紧张，则可以抛弃这些对象。很多系统中的缓存对象都符合这样的场景。&nbsp;<br />在JDK1.2之后，Java对引用的概念做了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)四种，这四种引用的强度依次递减。</p>\n<p>⑴强引用（StrongReference）<br />强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。&nbsp;&nbsp;ps：强引用其实也就是我们平时A a = new A()这个意思。<br /><br />⑵软引用（SoftReference）<br />如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存（下文给出示例）。<br />软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。<br /><br />⑶弱引用（WeakReference）<br />弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。<br />弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br /><br />⑷虚引用（PhantomReference）<br />&ldquo;虚引用&rdquo;顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。<br />虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</p>\n<p>1 为什么需要使用软引用<br /><br />首先，我们看一个雇员信息查询系统的实例。我们将使用一个Java语言实现的雇员信息查询系统查询存储在磁盘文件或者数据库中的雇员人事档案信息。作为一个用户，我们完全有可能需要回头去查看几分钟甚至几秒钟前查看过的雇员档案信息(同样，我们在浏览WEB页面的时候也经常会使用&ldquo;后退&rdquo;按钮)。</p>\n<p>这时我们通常会有两种程序实现方式:</p>\n<p>一种是:</p>\n<p>把过去查看过的雇员信息保存在内存中，每一个存储了雇员档案信息的Java对象的生命周期贯穿整个应用程序始终;</p>\n<p>另一种是:</p>\n<p>当用户开始查看其他雇员的档案信息的时候，把存储了当前所查看的雇员档案信息的Java对象结束引用，使得垃圾收集线程可以回收其所占用的内存空间，当用户再次需要浏览该雇员的档案信息的时候，重新构建该雇员的信息。</p>\n<p>很显然，第一种实现方法将造成大量的内存浪费.</p>\n<p>而第二种实现的缺陷在于即使垃圾收集线程还没有进行垃圾收集，包含雇员档案信息的对象仍然完好地保存在内存中，应用程序也要重新构建一个对象。</p>\n<p>我们知道，访问磁盘文件、访问网络资源、查询数据库等操作都是影响应用程序执行性能的重要因素，如果能重新获取那些尚未被回收的Java对象的引用，必将减少不必要的访问，大大提高程序的运行速度。</p>\n<p><a href=\"https://blog.csdn.net/luzhensmart/article/details/81431212\" target=\"_blank\" rel=\"noopener\">原文：https://blog.csdn.net/luzhensmart/article/details/81431212</a></p>','在java中是通过引用来和对象进行关联的，也就是说如果要操作对象，必须通过引用来进行。那么很显然一个简单的办法就是通过引用计数来判断一个对象是否可以被回收。',NULL,0,1,1,'2019-11-26 14:00:00','2019-11-27 12:17:07',0,5),(10,'Reentrantlock ','<pre><strong>ReentrantLock 即可重入锁，实现了 Lock 和 Serializable 接口。</strong><br /><strong>在 Java 环境下 ReentrantLock 和 synchronized 都是可重入锁。<br /></strong></pre>\n<div>Lock和synchronized有以下几点不同：</div>\n<ul>\n<li>\n<div>原始结构</div>\n</li>\n<ul>\n<li>\n<div>synchronized 是关键字属于 JVM 层面，反应在字节码上是 monitorenter 和 monitorexit，其底层是通过 monitor 对象来完成，其实 wait/notify 等方法也是依赖 monitor 对象只有在同步快或方法中才能调用 wait/notify 等方法。</div>\n</li>\n<li>\n<div>Lock 是具体类（java.util.concurrent.locks.Lock）是 api 层面的锁。</div>\n</li>\n</ul>\n<li>\n<div>使用方法</div>\n</li>\n<ul>\n<li>\n<div>synchronized 不需要用户手动去释放锁，当 synchronized 代码执行完后系统会自动让线程释放对锁的占用。</div>\n</li>\n<li>\n<div>ReentrantLock 则需要用户手动的释放锁，若没有主动释放锁，可能导致出现死锁的现象，lock() 和 unlock() 方法需要配合 try/finally 语句来完成。</div>\n</li>\n</ul>\n<li>\n<div>等待是否可中断</div>\n</li>\n<ul>\n<li>\n<div>synchronized 不可中断，除非抛出异常或者正常运行完成。</div>\n</li>\n<li>\n<div>ReentrantLock 可中断，设置超时方法 tryLock(long timeout, TimeUnit unit)，lockInterruptibly() 放代码块中，调用 interrupt() 方法可中断。</div>\n</li>\n</ul>\n<li>\n<div>加锁是否公平</div>\n</li>\n<ul>\n<li>\n<div>synchronized 非公平锁</div>\n</li>\n<li>\n<div>ReentrantLock 默认非公平锁，构造方法中可以传入 boolean 值，true 为公平锁，false 为非公平锁。</div>\n</li>\n</ul>\n<li>\n<div>锁可以绑定多个 Condition</div>\n</li>\n<ul>\n<li>\n<div>synchronized 没有 Condition。</div>\n</li>\n<li>\n<div>ReentrantLock 用来实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不是像 synchronized 要么随机唤醒一个线程要么唤醒全部线程。</div>\n</li>\n</ul>\n</ul>\n<p>一个Reentrantlock版本的生产者消费者</p>\n<pre class=\"language-java\"><code>import java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class AirCondition {\n    private int num = 0;\n    private Lock lock = new ReentrantLock();\n    private Condition condition = lock.newCondition();\n\n    private void production() {\n        lock.lock();\n        try {\n            //1.判断\n            while (num &gt;= 1) {\n                condition.await();//代替this.wait()\n            }\n            //2.执行\n            this.num++;\n            System.out.println(Thread.currentThread().getName() + \"生产1个此时资源量：\" + num);\n            //3.通知\n            condition.signalAll();//代替notifyAll()\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n\n\n    }\n\n    private void consume() {\n        lock.lock();\n        try {\n            while (num &lt;= 0) {\n                condition.await();\n            }\n            this.num--;\n            System.out.println(Thread.currentThread().getName() + \"消费1个此时资源量：\" + num);\n            condition.signalAll();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n\n\n    }\n\n    public static void main(String[] args) {\n        AirCondition airCondition = new AirCondition();\n        new Thread(() -&gt; {\n            for (int i = 0; i &lt; 10; i++) {\n              airCondition.consume();\n            }\n\n        }, \"消费者1\").start();\n\n        new Thread(() -&gt; {\n            for (int i = 0; i &lt; 10; i++) {\n                airCondition.consume();\n            }\n\n        }, \"消费者2\").start();\n\n        new Thread(() -&gt; {\n            for (int i = 0; i &lt; 10; i++) {\n                airCondition.production();\n            }\n\n        }, \"生产者1\").start();\n\n        new Thread(() -&gt; {\n            for (int i = 0; i &lt; 10; i++) {\n                airCondition.production();\n            }\n\n        }, \"生产者2\").start();\n    }\n\n}\n</code></pre>\n<p>多线程之间按顺序调用实现 p1-&gt;p2-&gt;p3</p>\n<p>三个线程启动，p1 输出111 p2输出222 p3输出333 来十轮，如下</p>\n<pre class=\"language-java\"><code>import java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class AirCondition {\n    private int flag = 1;\n    private Lock lock = new ReentrantLock();\n    private Condition c1 = lock.newCondition();//print1\n    private Condition c2 = lock.newCondition();//print2\n    private Condition c3 = lock.newCondition();//print3\n\n    private void print1() {\n        lock.lock();\n        try {\n            //1.判断\n            while (flag != 1) {\n                c1.await();//代替this.wait()\n            }\n            //2.执行\n            System.out.println(Thread.currentThread().getName()+\" 111\");\n            //3.通知下一个\n            flag=2;\n            c2.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    private void print2() {\n        lock.lock();\n        try {\n            //1.判断\n            while (flag != 2) {\n                c2.await();//代替this.wait()\n            }\n            //2.执行\n            System.out.println(Thread.currentThread().getName()+\" 222\");\n            //3.通知下一个\n            flag=3;\n            c3.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    private void print3() {\n        lock.lock();\n        try {\n            //1.判断\n            while (flag != 3) {\n                c3.await();//代替this.wait()\n            }\n            //2.执行\n            System.out.println(Thread.currentThread().getName()+\" 333\");\n            //3.通知下一个\n            flag=1;\n            c1.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n\n\n    public static void main(String[] args) {\n        AirCondition airCondition = new AirCondition();\n        new Thread(() -&gt; {\n            for (int i = 0; i &lt; 10; i++) {\n              airCondition.print1();\n            }\n\n        }, \"p1\").start();\n\n        new Thread(() -&gt; {\n            for (int i = 0; i &lt; 10; i++) {\n                airCondition.print2();\n            }\n\n        }, \"p2\").start();\n\n        new Thread(() -&gt; {\n            for (int i = 0; i &lt; 10; i++) {\n                airCondition.print3();\n            }\n\n        }, \"p3\").start();\n\n\n    }   </code></pre>\n<pre class=\"language-java\"><code>p1 111\np2 222\np3 333\np1 111\np2 222\np3 333\np1 111\np2 222\np3 333\np1 111\np2 222\np3 333\np1 111\np2 222\np3 333\np1 111\np2 222\np3 333\np1 111\np2 222\np3 333\np1 111\np2 222\np3 333\np1 111\np2 222\np3 333\np1 111\np2 222\np3 333</code></pre>','ReentrantLock 即可重入锁，实现了 Lock 和 Serializable 接口。在 Java 环境下 ReentrantLock 和 synchronized 都是可重入锁。',NULL,1,1,1,'2019-11-26 14:00:00','2019-11-29 16:55:05',0,1),(11,'对 ThreadPoolExector 的理解','<h3>为什使用线程池，线程池的优势？</h3>\n<div>线程池用于多线程处理中，它可以根据系统的情况，可以有效控制线程执行的数量，优化运行效果。线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，那么超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。</div>\n<div>主要特点为：</div>\n<ul>\n<li>\n<div>线程复用</div>\n</li>\n<li>\n<div>控制最大并发数量</div>\n</li>\n<li>\n<div>管理线程</div>\n</li>\n</ul>\n<div>主要优点</div>\n<ul>\n<li>\n<div>降低资源消耗，通过重复利用已创建的线程来降低线程创建和销毁造成的消耗。</div>\n</li>\n<li>\n<div>提高相应速度，当任务到达时，任务可以不需要的等到线程创建就能立即执行。</div>\n</li>\n<li>\n<div>提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅仅会消耗系统资源，还会降低体统的稳定性，使用线程可以进行统一分配，调优和监控。</div>\n</li>\n</ul>\n<h3>创建线程的几种方式</h3>\n<ul>\n<li>\n<div>继承 Thread</div>\n</li>\n<li>\n<div>实现 Runnable 接口</div>\n</li>\n<li>\n<div>实现 Callable</div>\n</li>\n<li>使用线程池</li>\n</ul>\n<h4>编码实现</h4>\n<ul>\n<li>\n<div>Executors.newSingleThreadExecutor()：只有一个线程的线程池，因此所有提交的任务是顺序执行</div>\n</li>\n<li>\n<div>Executors.newCachedThreadPool()：线程池里有很多线程需要同时执行，老的可用线程将被新的任务触发重新执行，如果线程超过60秒内没执行，那么将被终止并从池中删除</div>\n</li>\n<li>\n<div>Executors.newFixedThreadPool()：拥有固定线程数的线程池，如果没有任务执行，那么线程会一直等待</div>\n</li>\n<li>\n<div>Executors.newScheduledThreadPool()：用来调度即将执行的任务的线程池</div>\n</li>\n<li>\n<div>Executors.newWorkStealingPool()： newWorkStealingPool适合使用在很耗时的操作，但是newWorkStealingPool不是ThreadPoolExecutor的扩展，它是新的线程池类ForkJoinPool的扩展，但是都是在统一的一个Executors类中实现，由于能够合理的使用CPU进行对任务操作（并行操作），所以适合使用在很耗时的任务中</div>\n</li>\n</ul>\n<h4>ThreadPoolExecutor</h4>\n<div>ThreadPoolExecutor作为java.util.concurrent包对外提供基础实现，以内部线程池的形式对外提供管理任务执行，线程调度，线程池管理等等服务。</div>\n<h3>线程池的几个重要参数介绍？</h3>\n<table><colgroup><col /><col /></colgroup>\n<tbody>\n<tr>\n<td>参数</td>\n<td>作用</td>\n</tr>\n<tr>\n<td>corePoolSize</td>\n<td>核心线程池大小</td>\n</tr>\n<tr>\n<td>maximumPoolSize</td>\n<td>最大线程池大小</td>\n</tr>\n<tr>\n<td>keepAliveTime</td>\n<td>线程池中超过 corePoolSize 数目的空闲线程最大存活时间；可以allowCoreThreadTimeOut(true) 使得核心线程有效时间</td>\n</tr>\n<tr>\n<td>TimeUnit</td>\n<td>keepAliveTime 时间单位</td>\n</tr>\n<tr>\n<td>workQueue</td>\n<td>阻塞任务队列</td>\n</tr>\n<tr>\n<td>threadFactory</td>\n<td>新建线程工厂</td>\n</tr>\n<tr>\n<td>RejectedExecutionHandler</td>\n<td>当提交任务数超过 maxmumPoolSize+workQueue 之和时，任务会交给RejectedExecutionHandler 来处理</td>\n</tr>\n</tbody>\n</table>\n<div>说说线程池的底层工作原理？</div>\n<div>重点讲解： 其中比较容易让人误解的是：corePoolSize，maximumPoolSize，workQueue之间关系。</div>\n<ol>\n<li>\n<div>当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。</div>\n</li>\n<li>\n<div>当线程池达到corePoolSize时，新提交任务将被放入 workQueue 中，等待线程池中任务调度执行。</div>\n</li>\n<li>\n<div>当workQueue已满，且 maximumPoolSize 大于 corePoolSize 时，新提交任务会创建新线程执行任务。</div>\n</li>\n<li>\n<div>当提交任务数超过 maximumPoolSize 时，新提交任务由 RejectedExecutionHandler 处理。</div>\n</li>\n<li>\n<div>当线程池中超过corePoolSize 线程，空闲时间达到 keepAliveTime 时，关闭空闲线程 。</div>\n</li>\n<li>\n<div>当设置allowCoreThreadTimeOut(true) 时，线程池中 corePoolSize 线程空闲时间达到 keepAliveTime 也将关闭。</div>\n</li>\n</ol>\n<p><img src=\"http://blog.cuzz.site/2019/04/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/92ad4409-2ab4-388b-9fb1-9fc4e0d832cd.jpg\" alt=\"\" /></p>\n<h3 id=\"线程池的拒绝策略你谈谈？\">线程池的拒绝策略你谈谈？</h3>\n<ul>\n<li>是什么\n<ul>\n<li>等待队列已经满了，再也塞不下新的任务，同时线程池中的线程数达到了最大线程数，无法继续为新任务服务。</li>\n</ul>\n</li>\n<li>拒绝策略\n<ul>\n<li>AbortPolicy：处理程序遭到拒绝将抛出运行时 RejectedExecutionException</li>\n<li>CallerRunsPolicy：线程调用运行该任务的 execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。</li>\n</ul>\n</li>\n<li>DiscardPolicy：不能执行的任务将被删除\n<ul>\n<li>DiscardOldestPolicy：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"你在工作中单一的、固定数的和可变的三种创建线程池的方法，你用哪个多，超级大坑？\">你在工作中单一的、固定数的和可变的三种创建线程池的方法，你用哪个多，超级大坑？</h3>\n<p>如果读者对Java中的阻塞队列有所了解的话，看到这里或许就能够明白原因了。</p>\n<p>Java中的BlockingQueue主要有两种实现，分别是ArrayBlockingQueue 和 LinkedBlockingQueue。</p>\n<p>ArrayBlockingQueue是一个用数组实现的有界阻塞队列，必须设置容量。</p>\n<p>LinkedBlockingQueue是一个用链表实现的有界阻塞队列，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。</p>\n<p>这里的问题就出在：不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。也就是说，如果我们不设置LinkedBlockingQueue的容量的话，其默认容量将会是Integer.MAX_VALUE。</p>\n<p>而newFixedThreadPool中创建LinkedBlockingQueue时，并未指定容量。此时，LinkedBlockingQueue就是一个无边界队列，对于一个无边界队列来说，是可以不断的向队列中加入任务的，这种情况下就有可能因为任务过多而导致内存溢出问题。</p>\n<p>上面提到的问题主要体现在newFixedThreadPool和newSingleThreadExecutor两个工厂方法上，并不是说newCachedThreadPool和newScheduledThreadPool这两个方法就安全了，这两种方式创建的最大线程数可能是Integer.MAX_VALUE，而创建这么多线程，必然就有可能导致OOM。</p>\n<h3 id=\"你在工作中是如何使用线程池的，是否自定义过线程池使用？\">你在工作中是如何使用线程池的，是否自定义过线程池使用？</h3>\n<p>自定义线程池</p>\n<pre class=\"language-java\"><code>public class ThreadPoolExecutorDemo {\n\n    public static void main(String[] args) {\n        Executor executor = new ThreadPoolExecutor(2, 3, 1L, TimeUnit.SECONDS,\n                new LinkedBlockingQueue&lt;&gt;(5), \n                Executors.defaultThreadFactory(), \n                new ThreadPoolExecutor.DiscardPolicy());\n    }\n}</code></pre>\n<h3 id=\"合理配置线程池你是如果考虑的？\">合理配置线程池你是如果考虑的？</h3>\n<ul>\n<li>CPU 密集型\n<ul>\n<li>CPU 密集的意思是该任务需要大量的运算，而没有阻塞，CPU 一直全速运行。</li>\n<li>CPU 密集型任务尽可能的少的线程数量，一般为 CPU 核数 + 1 个线程的线程池。</li>\n</ul>\n</li>\n<li>IO 密集型\n<ul>\n<li>由于 IO 密集型任务线程并不是一直在执行任务，可以多分配一点线程数，如 CPU * 2 。</li>\n<li>也可以使用公式：CPU 核数 / (1 - 阻塞系数)；其中阻塞系数在 0.8 ～ 0.9 之间。</li>\n</ul>\n</li>\n</ul>','线程池用于多线程处理中，它可以根据系统的情况，可以有效控制线程执行的数量，优化运行效果。线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，那么超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。',NULL,1,1,0,'2019-11-26 14:00:00','2019-11-29 17:02:48',0,1),(12,'CountDownLatch','<div>\n<p>countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。</p>\n<p>是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。</p>\n<p>countDownLatch类中只提供了一个构造器：</p>\n<pre class=\"line-numbers  language-cpp\"><code>//参数count为计数值\npublic CountDownLatch(int count) {  };</code></pre>\n<pre class=\"line-numbers  language-java\"><code>//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行\npublic void await() throws InterruptedException { };   \n//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行\npublic boolean await(long timeout, TimeUnit unit) throws InterruptedException { };  \n//将count值减1\npublic void countDown() { };  </code></pre>\n</div>\n<p>演示：教师有6个同学和班长，班长需要等6个同学都走后才能锁门。</p>\n<pre class=\"language-java\"><code>import java.util.concurrent.CountDownLatch;\n\npublic class CountdownLatchDemo {\n    public static void main(String[] args) throws InterruptedException {\n        CountDownLatch countDownLatch=new CountDownLatch(6);//6个线程\n        for (int i=0;i&lt;6;i++){\n            new Thread(()-&gt;{\n                System.out.println(Thread.currentThread().getName()+ \"学生离开教室\");\n                countDownLatch.countDown();\n            },String.valueOf(i)).start();\n        }\n        countDownLatch.await();//6线程个执行完才执行下面\n        System.out.println(\"班长锁门！\");\n\n    }\n}\n</code></pre>\n<pre class=\"language-java\"><code>0学生离开教室\n1学生离开教室\n3学生离开教室\n4学生离开教室\n2学生离开教室\n5学生离开教室\n班长锁门！</code></pre>\n<hr />\n<p><strong>场景说明：</strong></p>\n<ul>\n<li>模拟多线程分组计算</li>\n<li>有一个大小为50000的随机数组，用5个线程分别计算10000个元素的和</li>\n<li>然后在将计算结果进行合并，得出最后的结果。</li>\n</ul>\n<pre class=\"language-java\"><code>import java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.CountDownLatch;\n\npublic class CountdownLatchDemo {\n    public static void main(String[] args) throws InterruptedException {\n        //数组大小\n        int size = 50000;\n        //定义数组\n        int[] numbers = new int[size];\n        //随机初始化数组\n        Random random = new Random();\n        for (int i = 0; i &lt; size; i++) {\n            numbers[i] = random.nextInt(100);\n        }\n\n        //单线程计算结果\n        System.out.println();\n        Long sum = 0L;\n        for (int i = 0; i &lt; size; i++) {\n            sum += numbers[i];\n        }\n        System.out.println(\"单线程计算结果：\" + sum);\n//----------------------------------------------------------------------------------------------------------------------\n        //定义五个Future去保存子数组计算结果\n        final int[] results = new int[5];\n        //子数组长度\n        int length = 10000;\n        CountDownLatch countDownLatch=new CountDownLatch(5);//5个线程\n        for (int i=0;i&lt;5;i++){\n            int finalI = i;\n            int[] subNumbers = Arrays.copyOfRange(numbers, (i * length), ((i + 1) * length)); //每个线程计算一份数组\n            new Thread(()-&gt;{\n                for (int j = 0; j &lt;subNumbers.length ; j++) {\n                    results[finalI]+=subNumbers[j];\n                }\n                countDownLatch.countDown();\n            },String.valueOf(i)).start();\n        }\n        countDownLatch.await();//5个线程个执行完才执行下面\n        int sums = 0;\n        for (int i = 0; i &lt; 5; i++) {\n            sums += results[i];\n        }\n        System.out.println(\"多线程计算结果：\" + sums);\n\n    }\n}\n</code></pre>\n<pre class=\"language-java\"><code>单线程计算结果：2483567\n多线程计算结果：2483567</code></pre>','countDownLatch是在java1.5被引入，跟它一起被引入的工具类还有CyclicBarrier、Semaphore、concurrentHashMap和BlockingQueue。',NULL,1,1,1,'2019-11-26 14:00:00','2019-11-30 13:25:56',0,1),(13,'CyclicBarrier','<p>CyclicBarrier，是JDK1.5的java.util.concurrent并发包中提供的一个并发工具类。</p>\n<p>所谓Cyclic即 循环 的意思，所谓Barrier即 屏障 的意思。</p>\n<p>所以综合起来，CyclicBarrier指的就是 循环屏障，虽然这个叫法很奇怪，但是确能很好地表示它的作用。<br /><br /></p>\n<hr />\n<h3 id=\"2cyclicbarrier方法说明\">CyclicBarrier方法说明</h3>\n<h4><span style=\"background-color: #00ccff;\">CyclicBarrier(parties,Runnable barrierAction)</span></h4>\n<h5>初始化相互等待的线程数量以及屏障线程的构造方法。屏障线程的运行时机：等待的线程数量=parties之后，CyclicBarrier打开屏障之前。</h5>\n<h4><span style=\"background-color: #00ccff;\">await()</span></h4>\n<h5>在CyclicBarrier上进行阻塞等待，直到发生以下情形之一：</h5>\n<ul>\n<li>\n<h5>在CyclicBarrier上等待的线程数量达到parties，则所有线程被释放，继续执行。</h5>\n</li>\n<li>\n<h5>当前线程被中断，则抛出InterruptedException异常，并停止等待，继续执行。</h5>\n</li>\n<li>\n<h5>当前线程被中断，则抛出InterruptedException异常，并停止等待，继续执行。</h5>\n</li>\n<li>\n<h5>其他等待的线程被中断，则当前线程抛出BrokenBarrierException异常，并停止等待，继续执行。</h5>\n</li>\n<li>\n<h5>其他线程调用CyclicBarrier.reset()方法，则当前线程抛出BrokenBarrierException异常，并停止等待，继续执行。</h5>\n</li>\n</ul>\n<p><span style=\"background-color: #00ccff;\"><strong>await(timeout,TimeUnit)</strong></span></p>\n<h5>在CyclicBarrier上进行限时的阻塞等待</h5>\n<hr />\n<h5>应用场景：收集齐7个龙珠可以召唤神龙，召唤后，还可以收集召唤。。。</h5>\n<pre class=\"language-java\"><code>import java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\n\npublic class CyclicBarrierDemo {\n    public static void main(String[] args) {\n        CyclicBarrier cyclicBarrier=new CyclicBarrier(7,()-&gt;{System.out.println(\"召唤神龙！\");});\n        for (int i = 0; i &lt;14 ; i++) {\n            final int tem=i;\n            new Thread(()-&gt;{\n                System.out.println(Thread.currentThread().getName()+\"收集到第\"+tem+\"个龙珠\");\n                try {\n                    cyclicBarrier.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n            },String.valueOf(i)).start();\n        }\n    }\n}\n</code></pre>\n<pre class=\"language-java\"><code>0收集到第0个龙珠\n1收集到第1个龙珠\n2收集到第2个龙珠\n3收集到第3个龙珠\n4收集到第4个龙珠\n5收集到第5个龙珠\n6收集到第6个龙珠\n召唤神龙！\n7收集到第7个龙珠\n8收集到第8个龙珠\n11收集到第11个龙珠\n12收集到第12个龙珠\n9收集到第9个龙珠\n10收集到第10个龙珠\n13收集到第13个龙珠\n召唤神龙！</code></pre>\n<p>&nbsp;</p>','CyclicBarrier，是JDK1.5的java.util.concurrent并发包中提供的一个并发工具类。所谓Cyclic即 循环 的意思，所谓Barrier即 屏障 的意思。',NULL,0,0,1,'2019-11-26 14:00:00','2019-11-30 13:12:41',0,5),(14,'标题14',NULL,'这有内容。。。简介',NULL,1,1,0,'2019-11-26 14:00:00','2019-06-23 13:08:23',0,2),(15,'title','content','outline',NULL,0,0,0,'2019-11-26 14:00:00','2019-01-11 00:00:00',0,5),(16,'标题16',NULL,'这有内容。。。简介',NULL,1,1,0,'2019-11-26 14:00:00','2019-06-23 13:08:23',0,2),(17,'标题17',NULL,'这有内容。。。简介',NULL,1,1,0,'2019-11-26 14:00:00','2019-06-23 13:08:23',0,2),(18,'标题18',NULL,'这有内容。。。简介',NULL,1,1,0,'2019-11-26 14:00:00','2019-06-23 13:08:23',0,2),(19,'标题19',NULL,'这有内容。。。简介',NULL,1,1,0,'2019-11-26 14:00:00','2019-06-23 13:08:23',0,2),(20,'title','content','outline',NULL,0,0,0,'2019-11-26 14:00:00','2019-01-11 00:00:00',0,5),(21,'标题21',NULL,'这有内容。。。简介',NULL,1,1,0,'2019-11-26 14:00:00','2019-06-23 13:08:23',0,3),(23,'标题23',NULL,'这有内容。。。简介',NULL,1,1,0,'2019-11-26 14:00:00','2019-06-23 13:08:23',0,3),(24,'标题24',NULL,'这有内容。。。简介',NULL,1,1,0,'2019-11-26 14:00:00','2019-06-23 13:08:23',0,3),(25,'标题25',NULL,'这有内容。。。简介',NULL,1,1,0,'2019-11-26 14:00:00','2019-06-23 13:08:23',0,3),(26,'标题26',NULL,'这有内容。。。简介',NULL,1,1,0,'2019-11-26 14:00:00','2019-06-23 13:08:23',0,3),(27,'标题27',NULL,'这有内容。。。简介',NULL,1,1,0,'2019-11-26 14:00:00','2019-06-23 13:08:23',0,3),(28,'标题28',NULL,'这有内容。。。简介',NULL,1,1,0,'2019-11-26 14:00:00','2019-06-23 13:08:23',0,3),(29,'标题29',NULL,'这有内容。。。简介',NULL,1,1,0,'2019-11-26 14:00:00','2019-06-23 13:08:23',0,3),(30,'标题30',NULL,'这有内容。。。简介',NULL,1,1,0,'2019-11-26 14:00:00','2019-06-23 13:08:23',0,3),(32,'title','content','outline',NULL,0,0,0,'2019-11-26 14:00:00','2019-01-11 00:00:00',0,3),(33,'title','content','outline',NULL,0,0,0,'2019-11-26 14:00:00','2019-01-11 00:00:00',0,5),(34,'title','content','outline',NULL,0,0,0,'2019-11-26 14:00:00','2019-01-11 00:00:00',0,5),(35,'title','content','outline',NULL,0,0,0,'2019-11-26 14:00:00','2019-01-11 00:00:00',0,5),(36,'99999999999','<p>9999999999999</p>','999999999',NULL,0,1,0,'2019-11-26 14:00:00','2019-10-30 18:57:40',0,4),(37,'99999999999','<p>9999999999999</p>','999999999',NULL,0,0,0,'2019-11-26 14:00:00','2019-10-30 18:58:51',0,4),(38,'测试','<p>测试</p>','999999999',NULL,0,0,0,'2019-11-26 14:00:00','2019-10-30 18:59:35',0,4),(39,'测试啊','<p>123</p>','',NULL,0,0,0,'2019-11-26 14:00:00','2019-10-30 19:14:14',0,1),(40,'测试嗯嗯嗯','<p>123</p>','',NULL,0,0,0,'2019-11-26 14:00:00','2019-10-30 19:14:42',0,1),(41,'55555555555','<p>5555555555555</p>','55555555',NULL,0,1,0,'2019-11-26 14:00:00','2019-10-30 19:32:09',0,3),(42,'999999','<p>9999999</p>','999999999',NULL,0,0,0,'2019-11-26 14:00:00','2019-10-30 19:36:27',0,2),(43,'Semaphore','<p>Semaphore和ReentrantLock类似，获取许可有公平策略和非公平许可策略，默认情况下使用非公平策略。</p>\n<p>　　当初始值为1时，可以用作互斥锁，并具备不可重入的加锁语义。</p>\n<p>　　Semaphore将AQS的同步状态用于保存当前可用许可的数量。</p>\n<p><strong>实现资源池：</strong></p>\n<p>　　一个固定长度的资源池，当池为空时，请求资源会失败。</p>\n<p>　　使用Semaphore可以实现当池为空时，请求会阻塞，非空时解除阻塞。</p>\n<p>　　也可以使用Semaphore将任何一种容器变成有界阻塞容器。</p>\n<p>应用场景：</p>\n<p>以一个停车场是运作为例。假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了六辆车，看门人允许其中三辆不受阻碍的进入，然后放下车拦，剩下的车则必须在入口等待，此后来的车也都不得不在入口处等待。这时，有一辆车离开停车场，看门人得知后，打开车拦，放入一辆，如果又离开两辆，则又可以放入两辆，如此往复。</p>\n<p>这个停车系统中，每辆车就好比一个线程，看门人就好比一个信号量，看门人限制了可以活动的线程。假如里面依然是三个车位，但是看门人改变了规则，要求每次只能停两辆车，那么一开始进入两辆车，后面得等到有车离开才能有车进入，但是得保证最多停两辆车。对于Semaphore类而言，就如同一个看门人，限制了可活动的线程数。<br /><br /></p>\n<pre class=\"language-java\"><code>import java.util.concurrent.Semaphore;\n\npublic class SemaphoreDemo {\n    public static void main(String[] args) {\n        Semaphore semaphore=new Semaphore(3);//最多3个车位\n        for (int i = 0; i &lt; 6; i++) {//6辆车\n            new Thread(()-&gt;{\n                try {\n                    semaphore.acquire();//占用车位\n                    System.out.println(Thread.currentThread().getName()+\" 抢到车位。\");\n                    Thread.sleep(2000);\n                    System.out.println(Thread.currentThread().getName()+\" 离开车位。\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }finally {\n                    semaphore.release();//释放信车位\n                }\n            },String.valueOf(i)).start();\n        }\n    }\n}\n</code></pre>\n<pre class=\"language-java\"><code>1 抢到车位。\n2 抢到车位。\n3 抢到车位。\n\n2 离开车位。\n3 离开车位。\n1 离开车位。\n5 抢到车位。\n0 抢到车位。\n4 抢到车位。\n\n0 离开车位。\n5 离开车位。\n4 离开车位。</code></pre>','Semaphore也叫信号量，在JDK1.5被引入，用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。还可以用来实现某种资源池，或者对容器施加边界。',NULL,0,1,1,'2019-11-30 19:48:23','2019-11-30 19:48:23',0,1);

/*Table structure for table `t_blog_tag` */

DROP TABLE IF EXISTS `t_blog_tag`;

CREATE TABLE `t_blog_tag` (
  `bl_id` int(11) NOT NULL,
  `ta_id` int(11) NOT NULL,
  KEY `bl_id` (`bl_id`),
  KEY `ta_id` (`ta_id`),
  CONSTRAINT `t_blog_tag_ibfk_1` FOREIGN KEY (`bl_id`) REFERENCES `t_blog` (`bl_id`),
  CONSTRAINT `t_blog_tag_ibfk_2` FOREIGN KEY (`ta_id`) REFERENCES `t_tag` (`ta_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `t_blog_tag` */

insert  into `t_blog_tag`(`bl_id`,`ta_id`) values (20,1),(20,2),(20,3),(36,4),(37,4),(38,4),(41,3),(41,5),(42,5),(14,1),(15,1),(16,1),(17,1),(18,1),(19,1),(20,1);

/*Table structure for table `t_comment` */

DROP TABLE IF EXISTS `t_comment`;

CREATE TABLE `t_comment` (
  `co_id` int(11) NOT NULL AUTO_INCREMENT,
  `nickname` varchar(32) NOT NULL,
  `email` varchar(32) NOT NULL,
  `content` varchar(128) DEFAULT NULL,
  `avatar` varchar(64) DEFAULT NULL,
  `creatdate` datetime DEFAULT NULL,
  `bl_id` int(11) NOT NULL,
  `parent_id` int(11) DEFAULT NULL,
  `ip_id` int(11) DEFAULT NULL,
  `adminComment` tinyint(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`co_id`),
  KEY `bl_id` (`bl_id`),
  KEY `comment_ibfk_2` (`parent_id`),
  KEY `comment_ibfk_3` (`ip_id`),
  CONSTRAINT `t_comment_ibfk_1` FOREIGN KEY (`bl_id`) REFERENCES `t_blog` (`bl_id`),
  CONSTRAINT `t_comment_ibfk_2` FOREIGN KEY (`parent_id`) REFERENCES `t_comment` (`co_id`) ON DELETE CASCADE,
  CONSTRAINT `t_comment_ibfk_3` FOREIGN KEY (`ip_id`) REFERENCES `t_ip` (`ip_id`)
) ENGINE=InnoDB AUTO_INCREMENT=40 DEFAULT CHARSET=utf8;

/*Data for the table `t_comment` */

insert  into `t_comment`(`co_id`,`nickname`,`email`,`content`,`avatar`,`creatdate`,`bl_id`,`parent_id`,`ip_id`,`adminComment`) values (1,'游客one','1333333@qq.com','文章不错点赞！',NULL,'2019-06-23 13:09:35',1,NULL,1,1),(2,'游客two','456798@qqcom','随便说点什么吧！！！',NULL,'2019-06-23 13:10:09',1,1,1,0),(3,'雷浩','123456@qq.com','内容内容内容内容内容内容','avatar','2019-06-24 00:00:00',1,NULL,1,0),(4,'测试','123@qq.com','ceshi',NULL,'2019-11-16 05:51:01',1,1,1,0),(5,'测试二','111@qq.com','哈哈',NULL,'2019-11-16 05:51:01',1,1,1,0),(6,'王五','555@qq.com','回复雷浩',NULL,'2019-11-09 12:25:05',1,3,1,0),(7,'阿斯','2910819096@qq.com','66666',NULL,'2019-11-09 12:28:51',1,3,1,0),(8,'77','775736156@qq.com','777',NULL,'2019-11-09 12:30:43',1,3,1,0),(9,'888','365651975@qq.com','回复77',NULL,'2019-11-09 12:31:57',1,8,1,0),(12,'阿飞','775736156@qq.com','啊哈哈',NULL,'2019-11-10 01:12:44',1,NULL,1,0),(13,'爱迪生','365651975@qq.com','6',NULL,'2019-11-10 01:13:42',1,12,1,0),(14,'阿斯达','365651975@qq.com','你好爱迪生',NULL,'2019-11-10 01:13:56',1,13,1,0),(15,'张无忌','775736156@qq.com','比较明显的评论！！！！！！！！！！！！！！',NULL,'2019-11-12 09:04:52',1,2,1,0),(16,'赵敏','2910819096@qq.com','我是赵敏啊！',NULL,'2019-11-12 09:08:55',1,15,1,0),(17,'张无忌','1143038749@qq.com','优秀啊 优秀',NULL,'2019-11-12 09:12:40',1,16,1,0),(18,'路人哈哈','775736156@qq.com','你们都这么厉害吗',NULL,'2019-11-12 11:58:23',1,NULL,1,0),(19,'路人哈哈','775736156@qq.com','666',NULL,'2019-11-15 06:19:53',19,NULL,1,0),(20,'路人哈哈','775736156@qq.com','1',NULL,'2019-11-15 06:20:00',19,NULL,1,0),(21,'路人哈哈','775736156@qq.com','2',NULL,'2019-11-15 06:20:03',19,20,1,0),(22,'路人哈哈','775736156@qq.com','3',NULL,'2019-11-15 06:20:07',19,21,1,0),(23,'路人哈哈','775736156@qq.com','3',NULL,'2019-11-15 06:20:12',19,19,1,0),(24,'路人哈哈','775736156@qq.com','3',NULL,'2019-11-15 06:20:15',19,19,1,0),(25,'nickname','123@qq.com','测试的',NULL,'2019-11-18 09:48:27',1,NULL,1,0),(26,'555','775736156@qq.com','12312321312312',NULL,'2019-11-18 17:06:40',1,NULL,1,0),(27,'555','775736156@qq.com','55555555555555555',NULL,'2019-11-18 17:07:57',1,NULL,1,0),(28,'555','775736156@qq.com','321',NULL,'2019-11-18 17:08:27',1,NULL,1,0),(33,'测试人员','666@qq.com','随便说点',NULL,'2019-11-22 18:48:30',1,NULL,2,0),(34,'测试人员','666@qq.com','谁啊',NULL,'2019-11-22 18:49:33',12,NULL,2,0),(35,'测试人员','666@qq.com','厉害',NULL,'2019-11-22 18:49:41',12,34,2,0),(36,'测试人员','666@qq.com','努伊斯',NULL,'2019-11-22 18:49:48',12,35,2,0),(37,'哈哈','111@qq.com','来来来',NULL,'2019-11-24 10:13:33',1,NULL,3,0),(38,'哈哈','111@qq.com','66666',NULL,'2019-11-24 10:14:01',4,NULL,3,0),(39,'张三','775736156@qq.com','牛皮',NULL,'2019-11-26 20:26:14',4,NULL,4,0);

/*Table structure for table `t_friend` */

DROP TABLE IF EXISTS `t_friend`;

CREATE TABLE `t_friend` (
  `fr_id` int(11) NOT NULL AUTO_INCREMENT,
  `nickname` varchar(32) NOT NULL,
  `description` varchar(256) DEFAULT NULL,
  `website` varchar(64) NOT NULL,
  `flag` int(2) NOT NULL DEFAULT '1',
  PRIMARY KEY (`fr_id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;

/*Data for the table `t_friend` */

insert  into `t_friend`(`fr_id`,`nickname`,`description`,`website`,`flag`) values (1,'王五','这是我的博客啊！哈哈哈哈','https://www.baidu.com/?tn=18029102_oem_dg',2),(2,'测试','博客哈哈','https://www.baidu.com/?tn=18029102_oem_dg',1),(3,'测试','博客哈哈','https://www.baidu.com/?tn=18029102_oem_dg',1),(4,'测试','博客哈哈','https://www.baidu.com/?tn=18029102_oem_dg',1),(5,'测试','博客哈哈','https://www.baidu.com/?tn=18029102_oem_dg',1),(6,'测试','博客哈哈','https://www.baidu.com/?tn=18029102_oem_dg',2),(7,'测试','博客哈哈','https://www.baidu.com/?tn=18029102_oem_dg',2);

/*Table structure for table `t_ip` */

DROP TABLE IF EXISTS `t_ip`;

CREATE TABLE `t_ip` (
  `ip_id` int(11) NOT NULL AUTO_INCREMENT,
  `address` varchar(64) NOT NULL,
  `avatar` varchar(128) NOT NULL,
  PRIMARY KEY (`ip_id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;

/*Data for the table `t_ip` */

insert  into `t_ip`(`ip_id`,`address`,`avatar`) values (1,'0:0:0:0:0:0:0:1','http://b-ssl.duitang.com/uploads/item/201802/21/20180221223815_xkkyq.jpg'),(2,'221.192.178.118','http://b-ssl.duitang.com/uploads/item/201802/21/20180221223815_xkkyq.jpg'),(3,'221.192.178.173','http://b-ssl.duitang.com/uploads/item/201802/21/20180221223815_xkkyq.jpg'),(4,'183.197.43.188','http://b-ssl.duitang.com/uploads/item/201802/21/20180221223815_xkkyq.jpg');

/*Table structure for table `t_tag` */

DROP TABLE IF EXISTS `t_tag`;

CREATE TABLE `t_tag` (
  `ta_id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(32) NOT NULL,
  PRIMARY KEY (`ta_id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;

/*Data for the table `t_tag` */

insert  into `t_tag`(`ta_id`,`name`) values (1,'标签1'),(2,'标签2'),(3,'标签3'),(4,'标签4'),(5,'标签5'),(6,'标签6');

/*Table structure for table `t_type` */

DROP TABLE IF EXISTS `t_type`;

CREATE TABLE `t_type` (
  `ty_id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(32) NOT NULL,
  PRIMARY KEY (`ty_id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;

/*Data for the table `t_type` */

insert  into `t_type`(`ty_id`,`name`) values (1,'JUC'),(2,'LeetCode'),(3,'算法'),(4,'微服务'),(5,'JVM'),(6,'Java');

/*Table structure for table `t_user` */

DROP TABLE IF EXISTS `t_user`;

CREATE TABLE `t_user` (
  `us_id` int(11) NOT NULL AUTO_INCREMENT,
  `nickname` varchar(32) NOT NULL,
  `username` varchar(32) NOT NULL,
  `password` varchar(32) NOT NULL,
  `email` varchar(32) DEFAULT NULL,
  `power` int(3) DEFAULT NULL,
  `about` varchar(256) DEFAULT NULL,
  `location` varchar(32) DEFAULT NULL,
  `vx` varchar(32) DEFAULT NULL,
  `qq` varchar(32) DEFAULT NULL,
  `finaldate` datetime DEFAULT NULL,
  `avatar` varchar(128) DEFAULT NULL,
  PRIMARY KEY (`us_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

/*Data for the table `t_user` */

insert  into `t_user`(`us_id`,`nickname`,`username`,`password`,`email`,`power`,`about`,`location`,`vx`,`qq`,`finaldate`,`avatar`) values (1,'低调做个路人','admin','775736156','1143038749@qq.com',NULL,'哈哈哈啊哈！！！哈哈哈啊哈！！！哈哈哈啊哈！！！哈哈哈啊哈！！！','北京朝阳区','18531159505','1143038749','2019-11-24 10:06:38','https://c-ssl.duitang.com/uploads/item/201601/15/20160115155749_BQ3Vk.thumb.700_0.jpeg');

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
